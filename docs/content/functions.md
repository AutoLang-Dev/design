# å‡½æ•°

AutoLang çš„å‡½æ•°è¯­æ³•å’Œ C++ å¾ˆåƒï¼š

```autolang
auto f(x1: T1, x2: T2, /*...*/) -> RT {
    // ...
}
```

ç›´æ¥çœç•¥æ‰ç±»å‹è¯´æ˜ç¬¦åˆ™å¦‚åŒå‡½æ•°æ¨¡æ¿ç®€å†™ï¼š

```autolang
auto f(x, y, /*...*/) -> RT {
    // ...
}
```

## UFCS

UFCS æ˜¯ Uniform Function Call Syntax çš„ç¼©å†™ï¼Œå¤§çº¦å¯ä»¥è¿™æ ·ç†è§£ï¼š

```autolang
auto f(x: T) -> RT {
    // ...
}

auto x = T{};
x.f(); // ç­‰ä»·äº f(x);
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šè¿‡ `.` åœ¨å¯¹è±¡ä¸Šè°ƒç”¨å‡½æ•°çš„æ—¶å€™ï¼Œä¼šå…ˆæŸ¥æ‰¾å…¶æˆå‘˜å‡½æ•°ã€‚å¦‚æœæ²¡æœ‰ç›¸åŒ¹é…çš„ï¼Œå†æŸ¥æ‰¾éæˆå‘˜å‡½æ•°ï¼Œå¹¶å°†è¯¥å¯¹è±¡æè‡³ç¬¬ä¸€å‚æ•°ã€‚éƒ½æŸ¥ä¸åˆ°åˆ™ç¨‹åºéè‰¯æ„ã€‚

Cpp2 å’Œ DLang ä¸­æœ‰ç›¸åŒçš„æ¦‚å¿µï¼ŒC# ä¸­ä¹Ÿæœ‰ç±»ä¼¼çš„æ‰©å±•æ–¹æ³•ã€‚

UFCSã€é‡è½½å†³è®®ã€æ¨¡æ¿åŒ¹é…ä¸‰è€…æ··åˆä½œç”¨å¯èƒ½ä¼šé€ æˆå¾ˆå¤šæ··ä¹±ï¼Œä¸è¿‡å†™ä»£ç çš„äººå¯ä»¥ä¸»è§‚é¿å…è¿™ç§æ··ä¹±ï¼Œæ‰€ä»¥ä¹‹åæˆ‘å†å¦æƒ³åŠæ³•ã€‚

### å¼ºåˆ¶æŒ‡å®š

ä¸ºæ­¤ï¼Œæ–°å¢ä¸¤ä¸ªâ€œè¿ç®—ç¬¦â€ï¼š `..` å’Œ `.|` ã€‚ç»™å®š `auto x = T{};` ï¼Œåˆ™æœ‰ï¼š

- `x..f()` è•´å«ç€ `x.T::f()`
- `x.|f()` è•´å«ç€ `f(x)`

å…¶ä¸­åè€…ç±»ä¼¼ MoonBit çš„ `|>` ç®¡é“è¿ç®—ç¬¦ï¼Œç¤¾åŒºä¸­ä¹Ÿç¡®å®æœ‰æåˆ°å®ƒä¸é“¾å¼è°ƒç”¨æœ‰é‡å¤æ€§ï¼Œå¸Œæœ›èƒ½å­¦ä¹  DLang çš„ UFCSã€‚

## åˆ†ç¦»å¼æˆå‘˜å‡½æ•°

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}
impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
// from https://course.rs/basic/method.html
```

åˆ†ç¦»å¼æˆå‘˜å‡½æ•°å¾ˆå¥½ï¼Œå®ƒèƒ½ç®€åŒ–è¯­æ³•ï¼ˆå’Œè¯­æ³•åˆ†æğŸ˜‹ï¼‰ï¼Œè€Œä¸”å…è®¸æ‹†åˆ†åˆ°å¤šä¸ªç¼–è¯‘å•å…ƒã€‚æ‰€ä»¥æˆ‘åœ¨ AutoLang ä¸­ä¹Ÿå¼•å…¥äº†åˆ†ç¦»å¼æˆå‘˜å‡½æ•°ã€‚æœ¬æ¥æˆ‘æƒ³äº†å¾ˆä¹…ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆè®¾è®¡è¯­æ³•ï¼Œä½†å½“æˆ‘å­¦ä¹  Cpp2 æ—¶ï¼Œçœ‹åˆ° UFCSï¼Œçµå…‰ä¹ç°ï¼Œç»ˆäºæƒ³å‡ºæ¥äº†ä¸€å¥—è®¾è®¡ã€‚

åˆ†ç¦»å¼æˆå‘˜å‡½æ•°çš„è¯­æ³•ç±»ä¼¼äº C# çš„æ‰©å±•æ–¹æ³•ï¼ˆå¹¶éæŠ„ï¼Œå®åœ¨æ˜¯å·§åˆï¼‰ï¼š

```autolang
struct Vec2 {
    x: Int;
    y: Int;
}

auto norm(this me: Vec2) {
    me.x * me.x + me.y * me.y
}

auto test1() {
    auto vec = Vec2{1, 2};
    auto n = vec.norm();
    std::println("|{}| ^ 2 = {}", vec, n);
    // å¯èƒ½çš„è¾“å‡ºï¼š|(1, 2)| ^ 2 = 5
}
```

å¯ä»¥æ¥å—çš„å†™æ³•æ˜¯ï¼š

- `vec.norm()`
- `vec.Vec2::norm()`
- `vec..norm()`
- `vec..Vec2::norm()`
- `Vec2::norm(vec)`

ä½† `vec.|norm()` æˆ– `vec.|Vec2::norm()` éè‰¯æ„ã€‚

åŒä¸€å¤„å†™å¤šä¸ªæˆå‘˜å‡½æ•°çš„è¯å°±æ¯”è¾ƒéº»çƒ¦ï¼Œæ¯ä¸ªéƒ½è¦æŒ‡å®š `this` å’Œ `: Vec2` ï¼Œæ‰€ä»¥æˆ‘æä¾›äº†å¤šä¸ªæˆå‘˜å‡½æ•°ç»‘å®šæˆä¸€ç»„çš„å†™æ³•ï¼Œç±»ä¼¼ Rust çš„ `impl` è¯­æ³•ï¼š

```autolang
embody Vec2 {
    auto get_x(me) {
        me.x
    }
    auto get_y(me) {
        me.y
    }
}
```

è¿™ä¸ª `embody` æ˜¯æˆ‘æ·±æ€ç†Ÿè™‘åä¹±é€‰çš„ä¸€ä¸ªè¯ï¼Œå¯èƒ½ä¼šæ”¹åŠ¨ã€‚

å‡è®¾æœ‰ä¸€ä¸ªç±»å‹ç‰¹å¾ï¼ˆç±»ä¼¼ Rust çš„ `trait` ï¼‰ `Formattable` éœ€è¦ä½ ä¸º `Vec2` å®ç°ï¼Œç±»ä¼¼äº Rust çš„ `impl` `for`è¯­æ³•ï¼Œåœ¨ AutoLang ä¸­å¦‚ä¸‹ï¼š

```autolang
embody Vec2 is Formattable {
    auto format(me) {
        std::format("{}", me);
    }
} // åªæ˜¯ä¸€ä¸ªä¾‹å­ï¼ŒçœŸæ­£çš„æ ¼å¼åŒ–æ˜¯ std::Formatter æ¥åš

auto test2() {
    static_assert(Vec2 is Formattable);
    auto vec = Vec2{1, 2};
    auto str = vec.Formattable::format();
    std::println("{}", str);
    // å¯èƒ½çš„è¾“å‡ºï¼š(1, 2)
}
```

`is` æ˜¯ä» Cpp2 ä¸­æŠ„è¿‡æ¥çš„ï¼Œå…·æœ‰å¤šç§å«ä¹‰ï¼Œåœ¨è¿™é‡Œè¡¨ç¤ºçº¦æŸã€‚ä¹‹ååœ¨[æ¨¡å¼åŒ¹é…](pattern-matching)ä¸­ä¹Ÿä¼šç”¨åˆ°å®ƒã€‚

## ä¸€äº›ä¾‹å­

æœ‰äº† UFCSï¼Œ `ranges` ç”¨èµ·æ¥å°±å¾ˆæ–¹ä¾¿äº†ï¼š

```autolang
auto x = views::iota(0uz, 5uz)
        .views::reverse()
        .views::transform([](x){ x * 2 })
        .ranges::to<std::Array>();
std::println("{}", x);
// å¯èƒ½çš„è¾“å‡ºï¼š[8, 6, 4, 2, 0]
```

åå­—è€¦åˆä¹Ÿå¾—åˆ°äº†ä¼˜åŒ–ï¼Œæ›´åŠ ç²¾å‡†äº†ï¼š

```autolang
struct OneInt {
    v: Int;
}

auto begin(this me: OneInt) {
    std::println("begin with {}", me.v);
}

embody OneInt is std::Range {
    auto begin(&me) -> *Int {
        me.v.std::address()
    }
    auto end(&me) -> *Int {
        me.begin() // æ˜¯ Range::begin å› ä¸º OneInt::begin è¢«é®è”½
          .std::next()
    }
}

auto test3() {
    auto x = OneInt{1};
    x.begin();
    assert(*x.Range::begin() == 1);
}
```
