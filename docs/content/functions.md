# å‡½æ•°

AutoLang çš„å‡½æ•°è¯­æ³•å’Œ Cpp2 å¾ˆåƒï¼š

```autolang
f: (x1: T1, x2: T2, /*...*/) -> RT = {
    // ...
}
```

ç›´æ¥çœç•¥æ‰ç±»å‹è¯´æ˜ç¬¦åˆ™å¦‚åŒå‡½æ•°æ¨¡æ¿ç®€å†™ï¼š

```autolang
f: (x, y, /*...*/) -> RT = {
    // ...
}
```

å‡½æ•°ä½“æ˜¯ä¸€å¯¹èŠ±æ‹¬å·æ‹¬èµ·æ¥çš„ 0 ä¸ªæˆ–å¤šä¸ªè¯­å¥ï¼Œå¤–åŠ ä¸€ä¸ªå¯é€‰çš„è¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼ï¼ˆç±»ä¼¼äº Rustï¼‰ï¼š

```autolang
f: () -> Int = {
    x := 1;
    y := 2;
    x + y
}
```

å¦‚æœä¸å†™æœ€åçš„è¡¨è¾¾å¼ï¼Œåˆ™å‡½æ•°çš„è¿”å›å€¼ç±»å‹å¿…é¡»æ˜¯ `Void` ç±»å‹ï¼š

```autolang
f: () -> Void = {
    std::println("return Void()");
}
```

å¯ä»¥çœç•¥ `-> RT` éƒ¨åˆ†ï¼Œåˆ™ä¼šè‡ªåŠ¨æ¨å¯¼ç±»å‹ã€‚

å¯ä»¥ç”¨ `return` è¯­å¥åœ¨ä¸­é€”è¿”å›ï¼š

```autolang
f: (double: Bool) = {
    std::println("ç¬¬ä¸€æ¬¡æ‰“å°");
    if !double {
        return;
    }
    std::println("ç¬¬äºŒæ¬¡æ‰“å°");
}

relu: <T> (x: T) = {
    zero := T();
    if x < zero {
        return zero;
    }
    x
}

g: (x) = x;
```

å¦‚æœå‡½æ•°ä½“ä»…æœ‰ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåˆ™å¯ä»¥çœå»èŠ±æ‹¬å·ï¼Œè¿™è¢«ç§°ä½œå‡½æ•°ç®€å†™ï¼š

```autolang
relu: <T> (x) = std::max(T(), x);
```

å¦‚æœä¸æä¾›å‡½æ•°åï¼Œåˆ™ç›¸å½“äºä¸€ä¸ª lambda è¡¨è¾¾å¼æˆ–åŒ¿åå‡½æ•°ï¼š

```autolang
std::ranges::sort(arr, :(lhs: &const std::String, rhs: &const std::String) = {
    lhs + rhs < rhs + lhs
})
```

ä»¥ä¸‹å±•ç¤ºäº†å‡½æ•°è¯­æ³•å¦‚ä½•åœ¨é€æ¸çœç•¥æˆåˆ†çš„è¿‡ç¨‹ä¸­ä½“ç°å‡ºé€šç”¨æ€§ï¼š

```autolang
equal: <T: type, U: type> (x: T, y: U) -> Bool = { return x == y; }
equal: <T, U> (x: T, y: U) -> Bool = { return x == y; }
equal: <T, U> (x: T, y: U) -> _ = { return x == y; }
equal: (x: _, y: _) -> _ = { return x == y; }
equal: (x: _, y: _) = { return x == y; }
equal: (x, y) = { return x == y; }
equal: (x, y) = { x == y }
equal: (x, y) = x == y;
:(x, y) = x == y
```

é‡æ–°æ³¨æ„ä¸€ä¸‹

```autolang
:(para: T = init) = { /*...*/ }
:(para: T = init) = statements;
```

è¿™ä¸¤ç§å½¢æ€ï¼Œæ¢ä¸€ä¸ªçœç•¥çš„æ–¹å‘ï¼Œæˆ‘ä»¬å¾—åˆ°äº†

```autolang
(x: T = init) { /*...*/ }
(x: T = init) statements;
```

å½¢å‚åˆ—è¡¨æˆä¸ºäº†æ•è·åˆ—è¡¨ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªå±€éƒ¨çš„ä½œç”¨åŸŸï¼š

```autolang
(i := 0uz)
while i < n {
    std::println("{}", i);
    i++;
}
```

è¿™å¦‚åŒä¸‹é¢çš„ä»£ç ï¼š

```cpp
for (auto i = 0uz; i < n; ++i) {
    std::println("{}", i);
}
```

```autolang
{
    i := 0uz;
    while i < n {
        std::println("{}", i);
        ++i;
    }
}
```

ä½¿ç”¨æ•è·åˆ—è¡¨çš„å¥½å¤„å°±æ˜¯é˜²æ­¢åå­—æ±¡æŸ“ã€æœ€å°åŒ–ç”Ÿå‘½å‘¨æœŸï¼Œè¿˜èƒ½å‡å°‘ç¼©è¿›å±‚æ•°ã€‚æ³¨æ„åˆ°ï¼Œæˆ‘æ›´å¤šä½¿ç”¨â€œæ•è·åˆ—è¡¨â€è€Œéå±€éƒ¨ä½œç”¨åŸŸï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬å¯ä»¥æŠŠæ•è·åˆ—è¡¨å’Œ lambda è¡¨è¾¾å¼ä¸€èµ·ä½¿ç”¨ï¼š

```autolang
(i := 0uz) :() = { 
    ret := i;
    i++;
    ret
}
```

å®ƒå¦‚åŒï¼š

```cpp
[i = 0uz] mutable {
    return i++;
}
```

## UFCS

UFCS æ˜¯ Uniform Function Call Syntax çš„ç¼©å†™ï¼Œå¤§çº¦å¯ä»¥è¿™æ ·ç†è§£ï¼š

```autolang
f: (x: T) -> RT = {
    // ...
}

x := T();
x.f(); // ç­‰ä»·äº f(x);
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šè¿‡ `.` åœ¨å¯¹è±¡ä¸Šè°ƒç”¨å‡½æ•°çš„æ—¶å€™ï¼Œä¼šå…ˆæŸ¥æ‰¾å…¶æˆå‘˜å‡½æ•°ã€‚å¦‚æœæ²¡æœ‰ç›¸åŒ¹é…çš„ï¼Œå†æŸ¥æ‰¾éæˆå‘˜å‡½æ•°ï¼Œå¹¶å°†è¯¥å¯¹è±¡æè‡³ç¬¬ä¸€å‚æ•°ã€‚éƒ½æŸ¥ä¸åˆ°åˆ™ç¨‹åºéè‰¯æ„ã€‚

Cpp2 å’Œ DLang ä¸­æœ‰ç›¸åŒçš„æ¦‚å¿µï¼ŒC# ä¸­ä¹Ÿæœ‰ç±»ä¼¼çš„æ‰©å±•æ–¹æ³•ã€‚

UFCSã€é‡è½½å†³è®®ã€æ¨¡æ¿åŒ¹é…ä¸‰è€…æ··åˆä½œç”¨å¯èƒ½ä¼šé€ æˆå¾ˆå¤šæ··ä¹±ï¼Œä¸è¿‡å†™ä»£ç çš„äººå¯ä»¥ä¸»è§‚é¿å…è¿™ç§æ··ä¹±ï¼Œæ‰€ä»¥ä¹‹åæˆ‘å†å¦æƒ³åŠæ³•ã€‚

### å¼ºåˆ¶æŒ‡å®š

ä¸ºæ­¤ï¼Œæ–°å¢ä¸¤ä¸ªâ€œè¿ç®—ç¬¦â€ï¼š `..` å’Œ `.|` ã€‚ç»™å®š `auto x = T{};` ï¼Œåˆ™æœ‰ï¼š

- `x..f()` è•´å«ç€ `x.T::f()`
- `x.|f()` è•´å«ç€ `f(x)`

å…¶ä¸­åè€…ç±»ä¼¼ MoonBit çš„ `|>` ç®¡é“è¿ç®—ç¬¦ï¼Œç¤¾åŒºä¸­ä¹Ÿç¡®å®æœ‰æåˆ°å®ƒä¸é“¾å¼è°ƒç”¨æœ‰é‡å¤æ€§ï¼Œå¸Œæœ›èƒ½å­¦ä¹  DLang çš„ UFCSã€‚

## æˆå‘˜å‡½æ•°

æˆ‘ä¸º AutoLang è®¾è®¡äº†ä¸¤å¥—æˆå‘˜å‡½æ•°è¯­æ³•ï¼Œå®ƒä»¬æ˜¯äº’ç›¸ç­‰ä»·çš„ã€‚

### åˆ†ç¦»å¼æˆå‘˜å‡½æ•°

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}
impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
// from https://course.rs/basic/method.html
```

åˆ†ç¦»å¼æˆå‘˜å‡½æ•°å¾ˆå¥½ï¼Œå®ƒèƒ½ç®€åŒ–è¯­æ³•ï¼ˆå’Œè¯­æ³•åˆ†æğŸ˜‹ï¼‰ï¼Œè€Œä¸”å…è®¸æ‹†åˆ†åˆ°å¤šä¸ªç¼–è¯‘å•å…ƒã€‚æ‰€ä»¥æˆ‘åœ¨ AutoLang ä¸­ä¹Ÿå¼•å…¥äº†åˆ†ç¦»å¼æˆå‘˜å‡½æ•°ã€‚æœ¬æ¥æˆ‘æƒ³äº†å¾ˆä¹…ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆè®¾è®¡è¯­æ³•ï¼Œä½†å½“æˆ‘å­¦ä¹  Cpp2 æ—¶ï¼Œçœ‹åˆ° UFCSï¼Œçµå…‰ä¹ç°ï¼Œç»ˆäºæƒ³å‡ºæ¥äº†ä¸€å¥—è®¾è®¡ã€‚

åˆ†ç¦»å¼æˆå‘˜å‡½æ•°çš„è¯­æ³•ç±»ä¼¼äº C# çš„æ‰©å±•æ–¹æ³•ï¼ˆå¹¶éæŠ„ï¼Œå®åœ¨æ˜¯å·§åˆï¼‰ï¼š

```autolang
Vec2: type = {
    x: Int,
    y: Int,
}

norm: (this me: Vec2) = me.x * me.x + me.y * me.y;

test1: () = {
    vec := Vec2(1, 2);
    n   := vec.norm();
    std::println("|{}| ^ 2 = {}", vec, n);
    // å¯èƒ½çš„è¾“å‡ºï¼š|(1, 2)| ^ 2 = 5
}
```

å¯ä»¥æ¥å—çš„å†™æ³•æ˜¯ï¼š

- `vec.norm()`
- `vec.Vec2::norm()`
- `vec..norm()`
- `vec..Vec2::norm()`
- `Vec2::norm(vec)`

ä½† `vec.|norm()` æˆ– `vec.|Vec2::norm()` éè‰¯æ„ã€‚

åŒä¸€å¤„å†™å¤šä¸ªæˆå‘˜å‡½æ•°çš„è¯å°±æ¯”è¾ƒéº»çƒ¦ï¼Œæ¯ä¸ªéƒ½è¦æŒ‡å®š `this` å’Œ `: Vec2` ï¼Œæ‰€ä»¥æˆ‘æä¾›äº†å¤šä¸ªæˆå‘˜å‡½æ•°ç»‘å®šæˆä¸€ç»„çš„å†™æ³•ï¼Œç±»ä¼¼ Rust çš„ `impl` è¯­æ³•ï¼š

```autolang
implement Vec2 {
    get_x: (me) = me.x;
    get_y: (me) = me.y;
}
```

å‡è®¾æœ‰ä¸€ä¸ªç±»å‹ç‰¹å¾ï¼ˆç±»ä¼¼ Rust çš„ `trait` ï¼‰ `Formattable` éœ€è¦ä½ ä¸º `Vec2` å®ç°ï¼Œç±»ä¼¼äº Rust çš„ `impl` `for`è¯­æ³•ï¼Œåœ¨ AutoLang ä¸­å¦‚ä¸‹ï¼š

```autolang
implement Vec2 is Formattable {
    format: (me) = std::format("{}", me);
} // åªæ˜¯ä¸€ä¸ªä¾‹å­ï¼ŒçœŸæ­£çš„æ ¼å¼åŒ–æ˜¯ std::Formatter æ¥åš

test2: () = {
    static_assert(Vec2 is Formattable);
    vec := Vec2(1, 2);
    str := vec.Formattable::format();
    std::println("{}", str);
    // å¯èƒ½çš„è¾“å‡ºï¼š(1, 2)
}
```

è¿˜æœ‰å†…åµŒ `is Trait` å—ï¼š

```autolang
Tag: type = {};

implement Tag {
    to_str: (_) = "Tag";
    is Formattable {
        format: (_) = "Tag";
    }
}
```

`is` æ˜¯ä» Cpp2 ä¸­æŠ„è¿‡æ¥çš„ï¼Œå…·æœ‰å¤šç§å«ä¹‰ï¼Œåœ¨è¿™é‡Œè¡¨ç¤ºçº¦æŸã€‚ä¹‹ååœ¨[æ¨¡å¼åŒ¹é…](pattern-matching)ä¸­ä¹Ÿä¼šç”¨åˆ°å®ƒã€‚

### åˆå¹¶å¼æˆå‘˜å‡½æ•°

æ€æ¥æƒ³å»è¿˜æ˜¯è§‰å¾—åˆå¹¶å¼æˆå‘˜å‡½æ•°æœ‰å…¶ä»·å€¼ï¼Œæ‰€ä»¥åŠ ä¸Šï¼š

```autolang
OneInt: type = {
    x: Int,
    to_str: (this &me) = std::format("OneInt({})", me.x);
    is Formattable {
        format: (&me) = me.to_str();
    }
}
```

ä¸ºäº†åŒºåˆ†æˆå‘˜å’Œå‡½æ•°å’Œå‡½æ•°æŒ‡é’ˆç±»å‹çš„æˆå‘˜ï¼Œæˆå‘˜å‡½æ•° `to_str` çš„å‚æ•°åˆ—è¡¨ä¸­çš„ `this` æ˜¯å¿…é¡»çš„ã€‚å…è®¸æ··ç”¨é€—å·å’Œåˆ†å·ï¼Œå®é™…ä¸Šåœ¨è¿™é‡Œä¸¤è€…æ²¡æœ‰åŒºåˆ«ã€‚æˆå‘˜å£°æ˜çš„æœ«å°¾å¿…é¡»æœ‰é€—å·æˆ–åˆ†å·ï¼Œé™¤äº†å†…åµŒ `is Trait` å—ã€éç®€å†™çš„å‡½æ•°å’Œæœ€åä¸€ä¸ªæˆå‘˜ã€‚

## ä¸€äº›ä¾‹å­

æœ‰äº† UFCSï¼Œ `ranges` ç”¨èµ·æ¥å°±å¾ˆæ–¹ä¾¿äº†ï¼š

```autolang
x := views::iota(0uz, 5uz)
    .views::reverse()
    .views::transform(:(x) = x * 2)
    .ranges::to<std::Array>();
std::println("{}", x);
// å¯èƒ½çš„è¾“å‡ºï¼š[8, 6, 4, 2, 0]
```

åå­—è€¦åˆä¹Ÿå¾—åˆ°äº†ä¼˜åŒ–ï¼Œæ›´åŠ ç²¾å‡†äº†ï¼š

```autolang
OneInt: type = {
    v: Int;
}

begin: (this me: OneInt) = {
    std::println("begin with {}", me.v);
}

implement OneInt is std::Range {
    begin: (&me) -> *Int = {
        me.v.std::address()
    }
    end: (&me) -> *Int = {
        me.begin() // æ˜¯ Range::begin å› ä¸º OneInt::begin è¢«é®è”½
          .std::next()
    }
}

test3: () = {
    x := OneInt(1);
    x.begin();
    assert(*x.Range::begin() == 1);
}
```
